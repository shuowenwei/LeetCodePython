# https://labuladong.gitee.io/algo/4/30/109/
# LC46, LC51
# 回溯算法其实就是我们常说的 DFS 算法，本质上就是一种暴力穷举算法。

# 解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：
# 1、路径：也就是已经做出的选择。
# 2、选择列表：也就是你当前可以做的选择。
# 3、结束条件：也就是到达决策树底层，无法再做选择的条件。


# result = []
# def backtrack(路径, 选择列表):
#     if 满足结束条件:
#         result.add(路径)
#         return
    
#     for 选择 in 选择列表:
#         // 前序遍历需要的操作
#         #做选择
#         将该选择从选择列表移除
#         backtrack(路径, 选择列表)
#         // 后序遍历需要的操作
#         #撤销选择
#         将该选择再加入选择列表

# void traverse(TreeNode root) {
#     for (TreeNode child : root.childern)
#         // 前序遍历需要的操作
#         traverse(child);
#         // 后序遍历需要的操作
# }
# 其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」


# https://labuladong.gitee.io/algo/4/30/111/
# 无论是排列、组合还是子集问题，简单说无非就是让你从序列 nums 中以给定规则取若干元素，主要有以下几种变体：
# 形式一、元素无重不可复选，即 nums 中的元素都是唯一的，每个元素最多只能被使用一次，这也是最基本的形式。
    # 以组合为例，如果输入 nums = [2,3,6,7]，和为 7 的组合应该只有 [7]。
# 形式二、元素可重不可复选，即 nums 中的元素可以存在重复，每个元素最多只能被使用一次。
    # 以组合为例，如果输入 nums = [2,5,2,1,2]，和为 7 的组合应该有两种 [2,2,2,1] 和 [5,2]。
# 形式三、元素无重可复选，即 nums 中的元素都是唯一的，每个元素可以被使用若干次。
    # 以组合为例，如果输入 nums = [2,3,6,7]，和为 7 的组合应该有两种 [2,2,3] 和 [7]。


