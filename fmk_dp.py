# https://labuladong.gitee.io/algo/1/3/
# https://labuladong.gitee.io/algo/3/23/66/

# 首先，动态规划问题的一般形式就是求最值。既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。

# 1. 首先，动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，
# 所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。
# 2. 而且，动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。
# 3. 另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，
# 只有列出正确的「状态转移方程」，才能正确地穷举。

# 以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。
# 明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。

# state-transition equation

# # 初始化 base case
# dp[0][0][...] = base
# # 进行状态转移
# for 状态1 in 状态1的所有取值：
#     for 状态2 in 状态2的所有取值：
#         for ...
#             dp[状态1][状态2][...] = 求最值(选择1，选择2...)


# 千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程。只要写出暴力解，优化方法无非是用备忘录或者 DP table，
# 再无奥妙可言。

# 细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，
# 只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：
# 这个技巧就是所谓的「状态压缩」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，
# 只记录必要的数据，上述例子就相当于把DP table 的大小从 n 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维
# 的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。